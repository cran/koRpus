# the plugin code was generated by this script
# you should not change the plugin code directly, but this script
# note: this script only creates objects in your workspace,
# *EXCEPT* for the last call, see below.

local({
# set the output directory to overwrite the actual plugin
output.dir <- tempdir()
overwrite <- TRUE

require(rkwarddev)

about.info <- "koRpus"



# <!-- TODO: check availablity of cor.freq.obj when checked and unchecked again... -->

# 	<logic>
# 		<convert id="logicTokenize" mode="equals" sources="radCustomTT.string" standard="file" />
# 		<convert id="logicTreeTagger" mode="equals" sources="radCustomTT.string" standard="fileTreeTagger" />
# 		<convert id="logicTagMode" mode="or" sources="logicTokenize;logicTreeTagger" />
# 		<connect client="frameTagFile.visible" governor="logicTagMode" />
# 		<connect client="saveTaggedText.enabled" governor="logicTagMode" />
# 		<connect client="TTtext.visible" governor="logicTreeTagger" />
# 		<connect client="TTroot.visible" governor="logicTreeTagger" />
# 		<connect client="TTroot.required" governor="logicTreeTagger" />
# 		<connect client="txtToTag.required" governor="logicTagMode" />
# 		<connect client="frameTokenizeOptions.visible" governor="logicTokenize" />
# 
# 		<convert id="logicTagModeObj" mode="equals" sources="radCustomTT.string" standard="object" />
# 		<connect client="frameCustomTT.visible" governor="logicTagModeObj" />
# 		<connect client="varTTCustom.required" governor="logicTagModeObj" />
# 
# 		<connect client="frameReadabilityIndices.enabled" governor="chkReadability.state" />
# 		<connect client="frameReadabilityNeedSylls.enabled" governor="chkReadability.state" />
# 		<connect client="frameReadabilityNeedWL.enabled" governor="chkReadability.state" />
# 		<connect client="saveReadb.enabled" governor="chkReadability.state" />
# 
# 		<convert id="logicHyphInvert" mode="equals" sources="Flesch.state;FleschKincaid.state;FarrJenkinsPaterson.state;FOG.state;SMOG.state;WheelerSmith.state;FORCAST.state;Strain.state;LinsearWrite.state;nWS.state;Coleman.state;ELF.state;Amdahl.state" standard="" />
# 		<connect client="rowChkHyph.enabled" governor="logicHyphInvert" />
# 
# 		<convert id="logicNeedsHyphenation" mode="or"
# 			sources="Flesch.state;FleschKincaid.state;FarrJenkinsPaterson.state;FOG.state;SMOG.state;WheelerSmith.state;FORCAST.state;Strain.state;LinsearWrite.state;nWS.state;Coleman.state;ELF.state;Amdahl.state" />
# 		<connect client="chkCustomHyph.state" governor="logicNeedsHyphenation" />
# 
# 		<convert id="logicNeedsLongDCWL" mode="or" sources="DaleChall.state;Bormuth.state;DRP.state" />
# 		<convert id="logicNeedsShortDCWL" mode="or" sources="Spache.state" />
# 		<connect client="readbWLldc.enabled" governor="logicNeedsLongDCWL"/>
# 		<connect client="readbWLldc.required" governor="logicNeedsLongDCWL"/>
# 		<connect client="readbWLsdc.enabled" governor="logicNeedsShortDCWL"/>
# 		<connect client="readbWLsdc.required" governor="logicNeedsShortDCWL"/>
# 
# 		<connect client="rowHyph.enabled" governor="chkCustomHyph.state" />
# 		<convert id="logicCustomHyphen" mode="equals" sources="radCustomHyph.string" standard="custom" />
# 		<connect client="frameCustomHyphen.visible" governor="logicCustomHyphen" />
# 		<connect client="varHyphenCustom.required" governor="logicCustomHyphen" />
# 		<convert id="logicSaveHyphen" mode="equals" sources="radCustomHyph.string" standard="auto" />
# 		<connect client="saveHyphen.enabled" governor="logicSaveHyphen" />
# 
# 		<connect client="frameLexDivMeasures.enabled" governor="chkLexDiv.state" />
# 		<connect client="frameLexDivChars.enabled" governor="chkLexDiv.state" />
# 		<connect client="LDShowTypes.enabled" governor="chkLexDiv.state" />
# 		<connect client="saveLexDiv.enabled" governor="chkLexDiv.state" />
# 		<connect client="showTypes.enabled" governor="chkLexDiv.state" />
# 		
# 		<connect client="saveFreq.enabled" governor="chkFreq.state" />
# 		<connect client="rowFreq.enabled" governor="chkFreq.state" />
# 		<!-- gets a little complex here... -->
# 		<convert id="enableFreqDir1" mode="equals" sources="drpFreqDB.string" standard="LCC" />
# 		<convert id="enableFreqDir2" mode="equals" sources="drpFreqDB.string" standard="celex" />
# 		<convert id="enableFreqDirAll" mode="or" sources="enableFreqDir1;enableFreqDir2" />
# 		<connect client="corpDBdir.visible" governor="enableFreqDirAll" />
# 		<connect client="corpDBdir.required" governor="enableFreqDirAll" />
# 		<connect client="inpCelexRunWd.visible" governor="enableFreqDirAll" />
# 		<connect client="inpCelexRunWd.enabled" governor="enableFreqDir2" />
# 		<connect client="inpCelexRunWd.required" governor="enableFreqDir2" />
# 		<connect client="saveCorpFreq.visible" governor="enableFreqDirAll" />
# 		<convert id="enableFreqObj" mode="equals" sources="drpFreqDB.string" standard="corpObj" />
# 		<connect client="varsFreq.visible" governor="enableFreqObj" />
# 		<connect client="varCorpFreqObj.visible" governor="enableFreqObj" />
# 		<connect client="varCorpFreqObj.required" governor="enableFreqObj" />
# 
# 		<connect client="Bormuth.state" governor="DRP.state" />
# 		<convert id="disableBormuth" mode="equals" sources="DRP.state" standard="" />
# 		<connect client="Bormuth.enabled" governor="disableBormuth" />
# 		<convert id="disableColeman" mode="notequals" sources="radCustomTT.string" standard="file" />
# 		<connect client="Coleman.enabled" governor="disableColeman" />
# 	</logic>

# 	<dialog label="Text Analysis">
# 		<tabbook>
# 			<tab id="tab_treetagger" label="POS Tagging">

kRp.POS.radio.mode <- rk.XML.radio(label="Select operation mode", options=list(
		"Tag a text file with tokenize()"=c(val="file", chk=TRUE),
		"Tag a text file with TreeTagger"=c(val="fileTreeTagger")#,
#			"Analyze already tagged object"=c(val="object")
	)
)

kRp.POS.vars <- rk.XML.varselector(id.name="varsTT")
kRp.POS.data <- rk.XML.varslot(
	label="Tagged text object (valid classes: kRp.tagged, kRp.text.analysis, kRp.freq.analysis)",
	source=kRp.POS.vars,
	classes=c("kRp.tagged","kRp.text.analysis","kRp.freq.analysis")
)
kRp.POS.frm.data <- rk.XML.frame(
	kRp.POS.vars,
	kRp.POS.data,
	label="Choose object to tag"
)

kRp.POS.brw.TTroot <- rk.XML.browser(
	label="TreeTagger root folder:",
	type="dir"
)
kRp.POS.txt.TTroot <- rk.XML.text("The TreeTagger folder is the one containing the bin, cmd and lib folders")
kRp.POS.drp.TTroot <- rk.XML.dropdown(label="Text language:", options=list(
		"English"=c(val="en", chk=TRUE),
		"German (UTF-8)"=c(val="de-utf8"),
		"German"=c(val="de"),
		"Italian (UTF-8)"=c(val="it-utf8"),
		"Italian"=c(val="it"),
		"Spanish (UTF-8)"=c(val="es-utf8"),
		"Spanish"=c(val="es"),
		"Russian (UTF-8)"=c(val="ru")
	)
)
kRp.POS.brw.text <- rk.XML.browser(
	label="Text to be analyzed:",
	filter="*.txt"
)
kRp.POS.frm.TT <- rk.XML.frame(
	kRp.POS.brw.TTroot,
	kRp.POS.txt.TTroot,
	kRp.POS.drp.TTroot,
	kRp.POS.brw.text
)

kRp.POS.chk.tkheadl <- rk.XML.cbox(
	label="Detect headlines (treated as sentences)",
	value="hline=TRUE"
)
kRp.POS.chk.tkparag <- rk.XML.cbox(
	label="Detect paragraphs",
	value="parag=TRUE"
)
kRp.POS.frm.tkopts <- rk.XML.frame(
	kRp.POS.chk.tkheadl,
	kRp.POS.chk.tkparag,
	label="tokenize() options"
)

# 					<frame id="frameShowTagged" label="Show tokenized results">
# 						<column>
# 							<checkbox id="showTagged" label="List tokenizing results in output (slow for long texts!)" value="tagged" checked="false" />
# 						</column>
# 					</frame>

# 					<saveobject id="saveTaggedText" label="Keep tagged text object" initial="tagged.text.obj" checkable="true" checked="true" />

kRp.POS.frm.show <- rk.XML.frame(
	kRp.POS.chk.show <- rk.XML.cbox(label="List tokenizing results in output (slow for long texts!)", value="tagged", id.name="showTagged")
)

kRp.POS.saveobj <- rk.XML.saveobj(label="Keep tagged text object", initial="tagged.text.obj", chk=TRUE, id.name="saveTaggedText")

kRp.dialog.POS <- rk.XML.dialog(
	rk.XML.row(
		rk.XML.col(
			kRp.POS.frm.data,
			kRp.POS.frm.TT,
			kRp.POS.frm.tkopts,
			rk.XML.stretch(),
			kRp.POS.frm.show,
			kRp.POS.saveobj
		)
	),
	label="POS Tagging"
)


# 			<tab id="tabReadability" label="Readability">
# 				<row>
# 					<checkbox id="chkReadability" label="Calculate readability" value="TRUE" checked="false" />
# 				</row>
# 				<row>
# 					<frame id="frameReadabilityIndices">
# 						<row>
# 							<column>


kRp.rdb.chk.LIX <- rk.XML.cbox(label="LÃ¤sbarhetsindex (LIX)", value="LIX", chk=TRUE, id.name="LIX")
kRp.rdb.chk.RIX <- rk.XML.cbox(label="Readability Index (RIX)", value="RIX", chk=TRUE, id.name="RIX")
kRp.rdb.chk.ARI <- rk.XML.cbox(label="Automated Readability Index (ARI)", value="ARI", chk=TRUE, id.name="ARI")
kRp.rdb.chk.ARINRI <- rk.XML.cbox(label="ARI (NRI)", value="ARI.NRI", chk=TRUE, id.name="ARINRI")

kRp.rdb.chk.ColemanLiau <- rk.XML.cbox(label="Coleman-Liau", value="Coleman.Liau", chk=TRUE, id.name="ColemanLiau")
kRp.rdb.chk.DickesSteiwer <- rk.XML.cbox(label="Dickes-Steiwer Handformel", value="Dickes.Steiwer", chk=TRUE, id.name="DickesSteiwer")
kRp.rdb.chk.Fucks <- rk.XML.cbox(label="Fucks' Stilcharakteristik", value="Fucks", chk=TRUE, id.name="Fucks")
kRp.rdb.chk.DanielsonBrian <- rk.XML.cbox(label="Danielson-Bryan (D 1+2)", value="Danielson.Bryan", chk=TRUE, id.name="DanielsonBryan")

kRp.rdb.frm.rdb <- rk.XML.frame(
	rk.XML.row(
		rk.XML.col(
			kRp.rdb.chk.LIX,
			kRp.rdb.chk.RIX,
			kRp.rdb.chk.ARI,
			kRp.rdb.chk.ARINRI
		),
		rk.XML.col(
			kRp.rdb.chk.ColemanLiau,
			kRp.rdb.chk.DickesSteiwer,
			kRp.rdb.chk.Fucks,
			kRp.rdb.chk.DanielsonBrian
		)
	),
	id.name="frameReadabilityIndices"
)


kRp.rdb.chk.Flesch <- rk.XML.cbox(label="Flesch Reading Ease", value="Flesch", chk=TRUE, id.name="Flesch")
kRp.rdb.chk.FleschPSK <- rk.XML.cbox(label="Flesch Reading Ease (Powers-Sumner-Kearl)", value="Flesch.PSK", chk=TRUE, id.name="FleschPSK")
kRp.rdb.chk.FleschKincaid <- rk.XML.cbox(label="Flesch-Kincaid Grade Level", value="Flesch.Kincaid", chk=TRUE, id.name="FleschKincaid")
kRp.rdb.chk.FarrJenkinsPaterson <- rk.XML.cbox(label="Farr-Jenkins-Paterson", value="Farr.Jenkins.Paterson", chk=TRUE, id.name="FarrJenkinsPaterson")
kRp.rdb.chk.FarrJenkinsPatersonPSK <- rk.XML.cbox(label="Farr-Jenkins-Paterson (Powers-Sumner-Kearl)", value="Farr.Jenkins.Paterson.PSK", chk=TRUE, id.name="FarrJenkinsPatersonPSK")
kRp.rdb.chk.FOG <- rk.XML.cbox(label="Gunning FOG", value="FOG", chk=TRUE, id.name="FOG")
kRp.rdb.chk.FOGPSK <- rk.XML.cbox(label="FOG (Powers-Sumner-Kearl)", value="FOG.PSK", chk=TRUE, id.name="FOGPSK")
kRp.rdb.chk.FOGNRI <- rk.XML.cbox(label="FOG (NRI)", value="FOG.NRI", chk=TRUE, id.name="FOGNRI")
kRp.rdb.chk.SMOG <- rk.XML.cbox(label="SMOG", value="SMOG", chk=TRUE, id.name="SMOG")
kRp.rdb.chk.Qu <- rk.XML.cbox(label="Qu (SMOG de)", value="SMOG.de", chk=TRUE, id.name="Qu")

kRp.rdb.chk.WheelerSmith <- rk.XML.cbox(label="Wheeler-Smith", value="Wheeler.Smith", chk=TRUE, id.name="WheelerSmith")
kRp.rdb.chk.WheelerSmithDe <- rk.XML.cbox(label="Wheeler-Smith (de)", value="Wheeler.Smith.de", chk=TRUE, id.name="WheelerSmithDe")
kRp.rdb.chk.FORCAST <- rk.XML.cbox(label="FORCAST", value="FORCAST", chk=TRUE, id.name="FORCAST")
kRp.rdb.chk.Strain <- rk.XML.cbox(label="Strain Index", value="Strain", chk=TRUE, id.name="Strain")
kRp.rdb.chk.LinsearWrite <- rk.XML.cbox(label="Linsear Write", value="Linsear.Write", chk=TRUE, id.name="LinsearWrite")
kRp.rdb.chk.nWS <- rk.XML.cbox(label="Wiener Sachtextformeln (nWS 1-4)", value="nWS", chk=TRUE, id.name="nWS")
kRp.rdb.chk.Coleman <- rk.XML.cbox(label="Coleman (C 1-4)", value="Coleman", chk=TRUE, id.name="Coleman")
kRp.rdb.chk.ELF <- rk.XML.cbox(label="Easy Listening Formula", value="ELF", chk=TRUE, id.name="ELF")
kRp.rdb.chk.TRI <- rk.XML.cbox(label="Kuntzsch's Text-Redundanz-Index", value="TRI", chk=TRUE, id.name="TRI")

kRp.rdb.frm.needSylls <- rk.XML.frame(
	rk.XML.text("Selecting one of these indices will automatically activate syllable count."),
	rk.XML.row(
		rk.XML.col(
			kRp.rdb.chk.Flesch,
			kRp.rdb.chk.FleschPSK,
			kRp.rdb.chk.FleschKincaid,
			kRp.rdb.chk.FarrJenkinsPaterson,
			kRp.rdb.chk.FarrJenkinsPatersonPSK,
			kRp.rdb.chk.FOG,
			kRp.rdb.chk.FOGPSK,
			kRp.rdb.chk.FOGNRI,
			kRp.rdb.chk.SMOG,
			kRp.rdb.chk.Qu
		),
		rk.XML.col(
			kRp.rdb.chk.WheelerSmith,
			kRp.rdb.chk.WheelerSmithDe,
			kRp.rdb.chk.FORCAST,
			kRp.rdb.chk.Strain,
			kRp.rdb.chk.LinsearWrite,
			kRp.rdb.chk.nWS,
			kRp.rdb.chk.Coleman,
			kRp.rdb.chk.ELF,
			kRp.rdb.chk.TRI,
			rk.XML.stretch()
		)
	),
	label="Formulae that need syllable count",
	id.name="frameReadabilityNeedSylls"
)

kRp.rdb.chk.DaleChall <- rk.XML.cbox(label="Dale-Chall (1995)", value="Dale.Chall", chk=TRUE, id.name="DaleChall")
kRp.rdb.chk.DaleChallPSK <- rk.XML.cbox(label="Dale-Chall (Powers-Sumner-Kearl)", value="Dale.Chall.PSK", chk=TRUE, id.name="DaleChallPSK")
kRp.rdb.chk.DaleChallOld <- rk.XML.cbox(label="Dale-Chall (1948)", value="Dale.Chall.old", chk=TRUE, id.name="DaleChallOld")
kRp.rdb.chk.Bormuth <- rk.XML.cbox(label="Bormuth Mean Cloze + Grade", value="Bormuth", chk=TRUE, id.name="Bormuth")
kRp.rdb.chk.Spache <- rk.XML.cbox(label="Spache", value="Spache", chk=TRUE, id.name="Spache")
kRp.rdb.chk.SpacheOld <- rk.XML.cbox(label="Spache (old)", value="Spache.old", chk=TRUE, id.name="SpacheOld")
kRp.rdb.chk.DRP <- rk.XML.cbox(label="Degrees of Reading Power", value="DRP", chk=TRUE, id.name="DRP")
kRp.rdb.brw.lDaleChall <- rk.XML.browser(label="Long Dale-Chall word list:", filter="*.txt", required=FALSE, id.name="readbWLldc")
kRp.rdb.brw.sDaleChall <- rk.XML.browser(label="Short Dale-Chall word list:", filter="*.txt", required=FALSE, id.name="readbWLsdc")

kRp.rdb.frm.NeedWL <- rk.XML.frame(
	rk.XML.text("If you select one of these indices you will also need to provide word lists as indicated below."),
	rk.XML.row(
		rk.XML.col(
			kRp.rdb.chk.DaleChall,
			kRp.rdb.chk.DaleChallPSK,
			kRp.rdb.chk.DaleChallOld,
			kRp.rdb.chk.Bormuth
		),
		rk.XML.col(
			kRp.rdb.chk.Spache,
			kRp.rdb.chk.SpacheOld,
			kRp.rdb.chk.DRP,
			rk.XML.stretch()
		)
	),
	rk.XML.row(
		rk.XML.col(
			kRp.rdb.brw.lDaleChall,
			kRp.rdb.brw.sDaleChall
		),
		id.name="rowWLfile"
	),
	id.name="frameReadabilityNeedWL",
	label="Formulae that need word lists"
)

kRp.rdb.frm.show <- rk.XML.frame(
	kRp.rdb.chk.show <- rk.XML.cbox(label="List results in output (slow for long texts!)", value="readability", id.name="showReadb")
)

kRp.rdb.saveobj <- rk.XML.saveobj(label="Keep results", initial="readability.obj", chk=TRUE, id.name="saveReadb")

kRp.tab.rdb <- list(
	kRp.rdb.frm.rdb,
	kRp.rdb.frm.needSylls,
	kRp.rdb.frm.NeedWL,
	kRp.rdb.frm.show,
	kRp.rdb.saveobj
)

kRp.hyph.chk.hyph <- rk.XML.cbox(label="Text hyphenation", value="TRUE", chk="false", id.name="chkCustomHyph")
kRp.hyph.rad.method <- rk.XML.radio(label="Hyphenation method", options=list(
	"Use automated hyphenation"=c(val="auto", chk=TRUE),
	"Use already hyphenated text object"=c(val="custom")
	),
	id.name="radCustomHyph"
)
kRp.hyph.vars <- rk.XML.varselector(id.name="varsHyph")
kRp.hyph.data <- rk.XML.varslot(
	label="Hyphenated text object (valid class: kRp.hyphen)",
	source=kRp.hyph.vars,
	classes=c("kRp.hyphen"),
	id.name="varHyphenCustom"
)
kRp.hyph.frm.data <- rk.XML.frame(
	kRp.hyph.vars,
	kRp.hyph.data
)

kRp.hyph.frm.show <- rk.XML.frame(
	kRp.hyph.chk.show <- rk.XML.cbox(label="List hyphenation results in output", value="hyph", id.name="showHyphenation")
)
kRp.hyph.saveobj <- rk.XML.saveobj(label="Keep hyphenated text object", initial="hyphenated.text.obj", chk=TRUE, id.name="saveHyphen")

kRp.tab.hyph <- list(
	rk.XML.row(
		rk.XML.col(kRp.hyph.chk.hyph),
		id.name="rowChkHyph"
	),
	kRp.hyph.vars,
	rk.XML.row(
		rk.XML.col(
			kRp.hyph.data,
			kRp.hyph.rad.method,
			rk.XML.stretch(),
			kRp.hyph.frm.show,
			kRp.hyph.saveobj
		),
	id.name="rowHyph")
)

kRp.comp.rdb <- rk.XML.dialog(
	rk.XML.tabbook(label="Readability",
		tabs=list("Readability"=kRp.tab.rdb, "Hyphenation"=kRp.tab.hyph)),
	label="Readability")

## make a whole component of the readability stuff
kRp.rdb.component <- rk.plugin.component("Readability",
	xml=list(
#		logic=kRp.rdb.lgc,
		dialog=kRp.comp.rdb),
#	js=list(
#		calculate=pd.js.calc),
#		printout=pd.js.print),
	hierarchy=list("analysis", "Text Analysis"),
	create=c("xml", "js"))



# 			<tab id="tabLexDiv" label="Lexical Diversity">
# 				<row>
# 					<checkbox id="chkLexDiv" label="Calculate lexical diversity" value="TRUE" checked="false" />
# 				</row>
kRp.ld.tab.measures <- list(
	rk.XML.row(
		rk.XML.col(
			kRp.ld.chk.TTR <- rk.XML.cbox("Type Token Ratio", value="TTR", chk=TRUE, id.name="TTR"),
			kRp.ld.chk.MSTTR <- rk.XML.cbox("Mean Segmental TTR", value="MSTTR", chk=TRUE, id.name="MSTTR"),
			kRp.ld.chk.Cld <- rk.XML.cbox("Herdan's C", value="C", chk=TRUE, id.name="Cld"),
			kRp.ld.chk.Rld <- rk.XML.cbox("Root TTR", value="R", chk=TRUE, id.name="Rld"),
			kRp.ld.chk.CTTR <- rk.XML.cbox("Corrected TTR", value="CTTR", chk=TRUE, id.name="CTTR"),
			kRp.ld.chk.Uld <- rk.XML.cbox("Uber Index", value="U", chk=TRUE, id.name="Uld"),
			kRp.ld.chk.Sld <- rk.XML.cbox("Summer", value="S", chk=TRUE, id.name="Sld"),
			kRp.ld.chk.Kld <- rk.XML.cbox("Yule's K", value="K", chk=TRUE, id.name="Kld"),
			kRp.ld.chk.Maas <- rk.XML.cbox("Maas", value="Maas", chk=TRUE, id.name="Maas"),
			kRp.ld.chk.HDD <- rk.XML.cbox("HD-D (idealized vocd-D)", value="HD-D", chk=TRUE, id.name="HDD"),
			kRp.ld.chk.MTLD <- rk.XML.cbox("Measure of Textual Lexical Diversity", value="MTLD", chk=TRUE, id.name="MTLD")
		),
	id.name="rowLD"),
	rk.XML.row(
		rk.XML.frame(kRp.ld.chk.showTypes <- rk.XML.cbox("List all identified types in output", value="types", id.name="types"),  id.name="frameLDShowTypes")
	),
	rk.XML.row(
		kRp.ld.saveobj <- rk.XML.saveobj(label="Keep lexical diversity results", initial="lex.div.obj", chk=TRUE, id.name="saveLexDiv")
	)
)

kRp.ld.tab.char <- list(
	rk.XML.row(
		rk.XML.col(
			kRp.ld.chk.TTRChar <- rk.XML.cbox("Type Token Ratio", value="TTR", id.name="TTRChar"),
			kRp.ld.chk.MSTTRChar <- rk.XML.cbox("Mean Segmental TTR", value="MSTTR", id.name="MSTTRChar"),
			kRp.ld.chk.CldChar <- rk.XML.cbox("Herdan's C", value="C", id.name="CldChar"),
			kRp.ld.chk.RldChar <- rk.XML.cbox("Root TTR", value="R", id.name="RldChar"),
			kRp.ld.chk.CTTRChar <- rk.XML.cbox("Corrected TTR", value="CTTR", id.name="CTTRChar"),
			kRp.ld.chk.UldChar <- rk.XML.cbox("Uber Index", value="U", id.name="UldChar"),
			kRp.ld.chk.SldChar <- rk.XML.cbox("Summer", value="S", id.name="SldChar"),
			kRp.ld.chk.KldChar <- rk.XML.cbox("Yule's K", value="K", id.name="KldChar"),
			kRp.ld.chk.MaasChar <- rk.XML.cbox("Maas", value="Maas", id.name="MaasChar"),
			kRp.ld.chk.HDDChar <- rk.XML.cbox("HD-D (idealized vocd-D)", value="HD-D", id.name="HDDChar"),
			kRp.ld.chk.MTLDChar <- rk.XML.cbox("Measure of Textual Lexical Diversity", value="MTLD", id.name="MTLDChar")
		),
	id.name="rowLDChar")
)
# 					</column>
# 				</row>
# 				<stretch />
# 				<row id="LDShowTypes">
# 					<frame id="frameLDShowTypes" label="Show types">
# 						<column>
# 						</column>
# 					</frame>
# 				</row>
# 				<row>
# 				</row>
# 			</tab>
# 			<tab id="tabDescript" label="Frequencies">

kRp.comp.ld <- rk.XML.dialog(
	rk.XML.tabbook(label="Lexical Diversity",
		tabs=list("Measures"=kRp.ld.tab.measures, "Characteristics (increasing text length)"=kRp.ld.tab.char)),
	label="Lexical Diversity"
)

## make a whole component of the readability stuff
kRp.ld.component <- rk.plugin.component("Lexical Diversity",
	xml=list(
#		logic=kRp.rdb.lgc,
		dialog=kRp.comp.ld),
#	js=list(
#		calculate=pd.js.calc),
#		printout=pd.js.print),
	hierarchy=list("analysis", "Text Analysis"),
	create=c("xml", "js"))

# 				<row>
# 					<checkbox id="chkFreq" label="Analyze frequencies" value="TRUE" checked="false" />
# 				</row>
# 				<row id="rowFreq"><column>
# 				<frame id="frameFreqDB" label="Frequencies from language corpora">
# 					<dropdown id="drpFreqDB" label="Use corpus database">
# 						<option value="none" label="none" checked="true" />
# 						<option value="corpObj" label="R object (class kRp.corp.freq)" />
# 						<option value="LCC" label="Leipzig Corpora Collection (read directory)" />
# 						<option value="celex" label="Celex (read directory)" />
# 					</dropdown>
# 					<browser id="corpDBdir" label="Root dir of database files" type="dir" required="false" />
# 					<input id="inpCelexRunWd" label="Number of running words" />
# 					<saveobject id="saveCorpFreq" label="Keep database object in workspace" initial="corp.freq.obj" checkable="true" />
# 					<varselector id="varsFreq" />
# 					<varslot id="varCorpFreqObj" classes="kRp.corp.freq" source="varsFreq" label="Corpus frequency object (valid class: kRp.corp.freq)" />
# 				</frame>
# 				<stretch />
# 				<frame id="frameFreqShowDesc" label="Show descriptive statistics">
# 					<column>
# 						<checkbox id="showFreqWClasses" label="Frequencies of word classes" value="freqWClass" checked="true" />
# 					</column>
# 				</frame>
# 				<saveobject id="saveFreq" label="Keep frequency results" initial="freq.analysis.obj" checkable="true" />
# 				</column></row>
# 			</tab>
# 		</tabbook>
# 	</dialog>
# </document>

kRp.comp.frq <- rk.XML.dialog(label="Frequencies")

#############
## if you run the following function call, files will be written to output.dir!
#############
# this is where it get's serious, that is, here all of the above is put together into one plugin

rk.kRp.dir <<- rk.plugin.skeleton(
	"koRpus",
	path=output.dir,
	xml=list(
#		logic=lgc.sect,
		dialog=kRp.dialog.POS),
	js=list(
		require="koRpus"#,
#		calculate=js.calc,
#		printout=js.print,
#		load.silencer=var.chk.suppress
	),
	pluginmap=list(name="Part-of-speech tagging", hierarchy=list("analysis", "Text Analysis")),
	components=list(kRp.rdb.component, kRp.ld.component),
	create=c("pmap", "xml", "js"),
	overwrite=overwrite,
	tests=FALSE,
#	edit=TRUE,
	load=TRUE)#,
#	show=TRUE)

})
